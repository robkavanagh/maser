import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.dates import drange, DateFormatter, AutoDateLocator
import datetime
from maser import maser
from fastapi import FastAPI, Request
from fastapi.responses import FileResponse, StreamingResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
import io
import csv
import base64

matplotlib.use('Agg')

plt.style.use('static/style.mplstyle')

rad_per_deg = np.pi / 180
t_ref_1970 = 2440587.5
sec_per_day = 86400

time_series_header = '''# Data generated by MASER app (v1)
#
# Stellar parameters:
# - Mass (solar masses) = %f
# - Radius (solar radii) = %f
# - Rotation period (days) = %f
# - Inclination (degrees) = %f
# - Magnetic field strength (G) = %f
# - Magnetic obliquity (degrees) = %f
# - Rotation phase at t_ref = %f
#
# Planetary parameters:
# - Orbital distance (stellar radii) = %f
# - Orbital inclination (degrees) = %f
# - Projected spin-orbit angle (degrees) = %f
# - Orbital phase at t_ref = %f
#
# Cone parameters:
# - Opening angle (degrees) = %f
# - Thickness (degrees) = %f
#
# Observing parameters:
# - Epoch (YYYY-MM-DD) = %s
# - Start time (UTC) = %s
# - Duration (hours) = %f
# - Time resolution (seconds) = %f
# - Observing frequency (MHz) = %f
# - Reference time (JD) = %f
'''

app = FastAPI()

# Serve index.html
@app.get('/', response_class = FileResponse)
def read_html():
	return FileResponse('index.html')

# Serve static files
app.mount('/static', StaticFiles(directory = 'static'))

@app.post('/run_maser')
async def run_maser(request: Request):

	params = await request.json()

	M_s = float(params['star']['M_s'])
	R_s = float(params['star']['R_s'])
	P_s = float(params['star']['P_s'])
	i_s = float(params['star']['i_s'])
	B_s = float(params['star']['B_s'])
	beta = float(params['star']['beta'])
	phi_s0 = float(params['star']['phi_s0'])

	a = float(params['planet']['a'])
	i_p = float(params['planet']['i_p'])
	lam = float(params['planet']['lam'])
	phi_p0 = float(params['planet']['phi_p0'])

	alpha = float(params['cone']['alpha'])
	dalpha = float(params['cone']['dalpha'])

	epoch = params['obs']['epoch']
	t_start = params['obs']['t_start']
	duration = float(params['obs']['duration'])
	dt = float(params['obs']['dt'])
	f = float(params['obs']['f'])
	t_ref = float(params['obs']['t_ref']) - t_ref_1970

	# Convert angles to radians
	i_s *= rad_per_deg
	beta *= rad_per_deg
	i_p *= rad_per_deg
	lam *= rad_per_deg
	alpha *= rad_per_deg
	dalpha *= rad_per_deg
	
	params = M_s, R_s, P_s, i_s, B_s, beta, phi_s0, a, i_p, lam, phi_p0, f, alpha, dalpha

	# Times - number of days since 1970-01-01 00:00
	t0 = datetime.datetime.strptime(epoch + ' ' + t_start, '%Y-%m-%d %H:%M')
	times = drange(t0, t0 + datetime.timedelta(hours = duration), datetime.timedelta(seconds = dt))

	# Compute lightcurve
	N, S = maser(params, times - t_ref)
	N = N.astype(int)
	S = S.astype(int)

	# Make figure
	fig, (ax_N, ax_S) = plt.subplots(2, sharex = True, figsize = (6, 2))

	for ax in [ax_N, ax_S]:
		ax.set_ylim(0, 1)
		ax.set_yticks([])
		ax.xaxis.set_major_formatter(DateFormatter('%H:%M'))
		ax.xaxis.set_major_locator(AutoDateLocator(maxticks = 8))

	ax_N.set_ylabel('North')
	ax_S.set_ylabel('South')
	ax_S.set_xlabel('Time on %s (UTC)'%epoch)

	dt /= sec_per_day
	edges = np.append(times - 0.5 * dt, times[-1] + 0.5 * dt)

	# Plot lightcurves
	ax_N.stairs(N, edges, ec = None, fc = 'xkcd:salmon', fill = True)
	ax_S.stairs(S, edges, ec = None, fc = 'xkcd:sky blue', fill = True)
	plt.subplots_adjust(left = 0.04, right = 0.98, bottom = 0.2, top = 0.95, hspace = 0.1)

	# Encode the figure
	fig_buffer = io.BytesIO()
	plt.savefig(fig_buffer, format = 'png', dpi = 300)
	plt.close(fig)
	fig_buffer.seek(0)
	fig_64 = base64.b64encode(fig_buffer.read()).decode('utf-8')

	# Lightcurve csv header
	csv_buffer = io.StringIO()
	csv_buffer.write(time_series_header%(M_s, R_s, P_s, i_s / rad_per_deg, B_s, beta / rad_per_deg, phi_s0, a, i_p / rad_per_deg, lam / rad_per_deg, phi_p0, alpha / rad_per_deg, dalpha / rad_per_deg, epoch, t_start, duration, dt * sec_per_day, f, t_ref))
	
	# Lightcurve data
	csv_buffer.write('Time (JD), N, S\n')
	csv.writer(csv_buffer).writerows(zip(times + t_ref_1970, N, S))
	csv_buffer.seek(0)
	csv_64 = base64.b64encode(csv_buffer.getvalue().encode('utf-8')).decode('utf-8')

	# Send image and time series to frontend
	return JSONResponse(content = {'fig': fig_64, 'csv': csv_64})